// ================================================================================
// MINEFEST-CORE BUILD SYSTEM ARCHITECTURE
// ================================================================================
// 
// COMPONENT SIGNPOST [Index: BUILD-01]
// Purpose: Complete build automation system for Minefest-Core mod development
// Architecture: Multi-environment deployment with dependency embedding
// Side: BUILD/GRADLE - affects all environments (dev, prod, client)
// Dependencies: ForgeGradle, MixinGradle, jarJar for LavaPlayer embedding
// 
// KEY FEATURES:
// - Automated environment synchronization (dev/prod/client)
// - LavaPlayer dependency embedding via jarJar
// - Version automation across all project files
// - Emergency process management for development conflicts
// - Code locking protocol enforcement
// - Multi-JAR creation (all/client/server specific)
//
// CRITICAL AUTOMATION COMMANDS:
// - ./gradlew buildAll        → Build and deploy to all environments
// - ./gradlew runServer       → Development server with auto-rebuild
// - ./gradlew incrementPatch  → Version management with auto-sync
// - ./gradlew clientJar       → Client-specific JAR (no server deps)
//
// ================================================================================

buildscript {
    repositories {
        maven { url = 'https://maven.minecraftforge.net' }
        mavenCentral()
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '6.0.+'
        classpath 'org.spongepowered:mixingradle:0.7.+'
    }
}

plugins {
    id 'eclipse'
    id 'maven-publish'
}

apply plugin: 'net.minecraftforge.gradle'
apply plugin: 'org.spongepowered.mixin'

// 🔒 LOCKED COMPONENT - Version Configuration (Do NOT lock version values)
// The version assignment itself is locked for stability, but version values remain flexible
version = project.mod_version
group = 'com.minefest'
archivesBaseName = 'minefest-essentials'

// 🔒 LOCKED COMPONENT - Java Toolchain Configuration
// This Java 17 + Oracle configuration is locked for build stability
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
        vendor = JvmVendorSpec.ORACLE
    }
}

// 🔒 LOCKED COMPONENT - Java Compilation Configuration
// These compiler args are locked as they solve critical module system conflicts
tasks.withType(JavaCompile) {
    options.compilerArgs << '-Xlint:unchecked'
    options.encoding = 'UTF-8'
    options.compilerArgs += [
        '--add-exports=java.base/sun.security.util=ALL-UNNAMED',
        '--add-exports=jdk.naming.dns/com.sun.jndi.dns=java.naming',
        '--add-opens=java.base/java.util.jar=ALL-UNNAMED',
        '--add-opens=java.base/java.lang=ALL-UNNAMED',
        '--add-opens=java.base/java.lang.reflect=ALL-UNNAMED',
        '--add-opens=java.base/java.text=ALL-UNNAMED',
        '--add-opens=java.desktop/java.awt.font=ALL-UNNAMED'
    ]
}

println "Java: ${System.getProperty('java.version')}, JVM: ${System.getProperty('java.vm.version')} (${System.getProperty('java.vendor')}), Arch: ${System.getProperty('os.arch')}"

// Enable Jar-in-Jar for LavaPlayer dependency embedding
jarJar.enable()

// 🔒 LOCKED COMPONENT - Minecraft Configuration
// Mappings and run configurations are locked for development stability
minecraft {
    mappings channel: 'official', version: minecraft_version
    
    runs {
        client {
            workingDirectory project.file('run')
            property 'forge.logging.markers', 'REGISTRIES'
            property 'forge.logging.console.level', 'debug'
            property 'forge.enabledGameTestNamespaces', 'minefest'
            
            // Memory allocation for development
            jvmArgs '-Xms2G', '-Xmx4G'
            jvmArgs '-XX:+UseG1GC'
            jvmArgs '-XX:MaxGCPauseMillis=50'
            
            // Simplified module system configuration
            jvmArgs '--add-opens=java.base/java.util.jar=ALL-UNNAMED'
            jvmArgs '--add-opens=java.base/java.lang.reflect=ALL-UNNAMED'
            jvmArgs '--add-opens=java.base/java.text=ALL-UNNAMED'
            jvmArgs '--add-opens=java.desktop/java.awt.font=ALL-UNNAMED'
            jvmArgs '--add-exports=java.base/sun.security.util=ALL-UNNAMED'
            jvmArgs '--add-exports=jdk.naming.dns/com.sun.jndi.dns=java.naming'
            
            // Disable module system conflicts by forcing all to unnamed module
            jvmArgs '--add-modules=ALL-SYSTEM'
            jvmArgs '--illegal-access=permit'
            
            // CLIENT-SPECIFIC FIX: Use classpath-only development (no jarJar conflicts)
            // This prevents HttpClient module conflicts since client uses Gradle classpath
            // instead of the jarJar dependencies embedded in production JARs
            
            // Force FML to scan classpath for mods instead of mods folder
            property 'fml.earlyprogresswindow', 'false'
            property 'forge.enabledGameTestNamespaces', 'minefest'
        }
        
        server {
            workingDirectory project.file('run')
            property 'forge.logging.markers', 'REGISTRIES'
            property 'forge.logging.console.level', 'debug'
            property 'forge.enabledGameTestNamespaces', 'minefest'
            
            // Memory allocation for development server
            jvmArgs '-Xms2G', '-Xmx6G'
            jvmArgs '-XX:+UseG1GC'
            jvmArgs '-XX:MaxGCPauseMillis=50'
            jvmArgs '-XX:G1HeapRegionSize=32M'
            
            // Module system configuration to avoid conflicts
            jvmArgs '--add-modules', 'ALL-SYSTEM'
            jvmArgs '--illegal-access=permit'
            jvmArgs '--add-opens=java.base/java.util.jar=ALL-UNNAMED'
            jvmArgs '--add-opens=java.base/java.lang.reflect=ALL-UNNAMED'
            jvmArgs '--add-opens=java.base/java.text=ALL-UNNAMED'
            jvmArgs '--add-opens=java.desktop/java.awt.font=ALL-UNNAMED'
            jvmArgs '--add-exports=java.base/sun.security.util=ALL-UNNAMED'
            jvmArgs '--add-exports=jdk.naming.dns/com.sun.jndi.dns=java.naming'
            
            // Handle duplicate module conflicts in development
            jvmArgs '--patch-module=org.apache.httpcomponents.httpclient=ALL-UNNAMED'
            jvmArgs '--patch-module=org.apache.httpcomponents.httpcore=ALL-UNNAMED'
            
            // Removed mods configuration to use jar in mods folder instead
        }
    }
}

// 🔒 LOCKED COMPONENT - Repository Configuration  
// These repositories are locked as they provide essential dependencies
repositories {
    maven { url = 'https://maven.minecraftforge.net' }
    mavenCentral()
    maven { url = 'https://m2.dv8tion.net/releases' }
    maven { 
        name = 'spigotmc-repo'
        url = 'https://hub.spigotmc.org/nexus/content/repositories/snapshots/'
        content {
            includeGroup 'net.md-5'
        }
    }
    maven {
        name = 'sonatype'
        url = 'https://oss.sonatype.org/content/groups/public/'
    }
    maven {
        url = 'https://repo.papermc.io/repository/maven-public/'
    }
    // SpongeForge repository
    maven {
        name = 'sponge'
        url = 'https://repo.spongepowered.org/maven'
    }
    // LuckPerms API repository (moved to official)
    maven {
        name = 'luckperms'
        url = 'https://oss.sonatype.org/content/repositories/snapshots/'
    }
}

// 🔒 LOCKED COMPONENT - Core Dependencies
// These dependencies are locked for functionality stability (versions may be updated)
dependencies {
    minecraft "net.minecraftforge:forge:${minecraft_version}-${forge_version}"
    
    // LavaPlayer: compileOnly for compilation, jarJar for production distribution (MINIMAL - only missing dependencies)
    compileOnly 'com.sedmelluq:lavaplayer:1.3.78'
    
    // Main LavaPlayer library
    jarJar(group: 'com.sedmelluq', name: 'lavaplayer', version: '[1.3.78,1.4.0)') {
        jarJar.pin(it, '1.3.78')
    }
    
    // CRITICAL: Include required LavaPlayer dependencies for production compatibility
    // These are needed for standalone server deployment
    jarJar(group: 'com.sedmelluq', name: 'lava-common', version: '[1.1.2,1.2.0)') {
        jarJar.pin(it, '1.1.2')
    }
    
    // Apache HttpClient dependencies - required for production server
    jarJar(group: 'org.apache.httpcomponents', name: 'httpclient', version: '[4.5.14,4.6.0)') {
        jarJar.pin(it, '4.5.14')
    }
    jarJar(group: 'org.apache.httpcomponents', name: 'httpcore', version: '[4.4.16,4.5.0)') {
        jarJar.pin(it, '4.4.16')
    }
    
    compileOnly 'net.md-5:bungeecord-api:1.20-R0.1'
    implementation 'com.google.guava:guava:32.1.2-jre'
    
    // SpongeForge API integration
    compileOnly 'org.spongepowered:spongeapi:8.2.0'
    
    // LuckPerms API for Sponge integration
    compileOnly 'net.luckperms:api:5.4'
}

// 🔒 LOCKED COMPONENT - Configuration Resolution Strategy
// This force resolution is locked to prevent dependency conflicts
configurations {
    all {
        resolutionStrategy {
            force 'com.github.oshi:oshi-core:6.4.10'
        }
    }
}

tasks.named('processResources').configure {
    // Remove the copy of Java files to resources
    // This was causing issues
}

// 🔒 LOCKED COMPONENT - Resource Processing Configuration
// This processResources configuration is locked for build stability
processResources {
    inputs.property "version", project.version
    inputs.property "minecraft_version", project.minecraft_version
    inputs.property "forge_version", project.forge_version
    inputs.property "loader_version_range", project.loader_version_range
    inputs.property "forge_version_range", project.forge_version_range
    inputs.property "minecraft_version_range", project.minecraft_version_range
    inputs.property "mod_authors", project.mod_authors
    inputs.property "mod_license", project.mod_license
    inputs.property "mod_description", project.mod_description

    // Exclude Java source files from resources
    exclude '**/*.java'

    filesMatching('META-INF/mods.toml') {
        expand 'version': project.version,
               'minecraft_version': project.minecraft_version,
               'forge_version': project.forge_version,
               'loader_version_range': project.loader_version_range,
               'forge_version_range': project.forge_version_range,
               'minecraft_version_range': project.minecraft_version_range,
               'mod_authors': project.mod_authors,
               'mod_license': project.mod_license,
               'mod_description': project.mod_description,
               'mod_version': project.mod_version
    }
}

// 🔒 LOCKED COMPONENT - Source Sets Configuration
// This source set configuration is locked for project structure stability
sourceSets {
    main {
        java {
            srcDirs = ['src/main/java']
        }
        resources {
            srcDirs = ['src/main/resources']
        }
    }
}

// 🔒 LOCKED COMPONENT - JAR Configuration with Shadow Plugin for LavaPlayer
// This JAR configuration is locked for build artifact stability and includes LavaPlayer dependencies
jar {
    manifest {
        attributes([
            "Specification-Title": "minefest",
            "Specification-Vendor": "minefestsareus",
            "Specification-Version": "1",
            "Implementation-Title": project.name,
            "Implementation-Version": project.jar.archiveVersion,
            "Implementation-Vendor" :"minefestsareus",
            "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
        ])
    }
    
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    exclude 'oshi.properties'
    exclude 'oshi.architecture.properties'
    exclude 'META-INF/MANIFEST.MF'
    exclude 'META-INF/*.SF'
    exclude 'META-INF/*.DSA'
    exclude 'META-INF/*.RSA'
    
    from sourceSets.main.output
}

// LavaPlayer dependency management handled by ForgeGradle automatically
// Dependencies marked as 'implementation' will be included in the runtime classpath

// 🔒 LOCKED COMPONENT - Directory Creation Tasks
// These directory creation tasks are locked for environment stability
task createModsDir {
    doLast {
        file('run/mods').mkdirs()
    }
}

task cleanModsDir {
    doLast {
        delete fileTree('run/mods') {
            include '*.jar'
        }
    }
}

// 🔒 LOCKED COMPONENT - Server Test Environment Creation
// This server test setup is locked for testing infrastructure stability
task createServerTestEnv {
    doLast {
        def serverTestDir = file('run/server-test')
        serverTestDir.mkdirs()
        
        def serverProperties = new File(serverTestDir, 'server-test.properties')
        if (!serverProperties.exists()) {
            serverProperties.text = """
#Minecraft server properties for testing
spawn-protection=16
max-tick-time=60000
query.port=25565
generator-settings={}
sync-chunk-writes=true
force-gamemode=false
allow-nether=true
enforce-whitelist=false
gamemode=survival
broadcast-console-to-ops=true
enable-query=false
player-idle-timeout=0
difficulty=easy
spawn-monsters=true
broadcast-rcon-to-ops=true
op-permission-level=4
pvp=true
entity-broadcast-range-percentage=100
snooper-enabled=true
level-type=default
hardcore=false
enable-command-block=false
max-players=20
network-compression-threshold=256
resource-pack-sha1=
max-world-size=29999984
function-permission-level=2
rcon.port=25575
server-port=25565
debug=false
server-ip=
spawn-npcs=true
allow-flight=false
level-name=world
view-distance=10
resource-pack=
spawn-animals=true
white-list=false
rcon.password=
generate-structures=true
max-build-height=256
online-mode=false
level-seed=
prevent-proxy-connections=false
enable-rcon=false
motd=Minefest Test Server
""".trim()
        }
        
        def opsFile = new File(serverTestDir, 'ops.json')
        if (!opsFile.exists()) {
            opsFile.text = '[]'
        }
    }
}

task setupServerTest {
    dependsOn 'build', 'createServerTestEnv', 'copyModToServerTest'
    group = 'minefest'
    description = 'Sets up the test server environment with the latest mod build'
}

// 🔒 LOCKED COMPONENT - Environment Synchronization Tasks
// These copy tasks are locked as they provide critical environment synchronization
task copyModToRunMods(type: Copy, dependsOn: 'jarJar') {
    from tasks.jarJar
    into 'run/mods'
    doFirst {
        delete fileTree('run/mods') {
            include '*.jar'
        }
    }
}

task copyModToServerMods(type: Copy, dependsOn: 'jarJar') {
    from tasks.jarJar
    into 'server/mods'
    doFirst {
        delete fileTree('server/mods') {
            include '*.jar'
        }
    }
}

task copyModToServerTest(type: Copy, dependsOn: 'jarJar') {
    from tasks.jarJar
    into 'run/server-test/mods'
    doFirst {
        delete fileTree('run/server-test/mods') {
            include '*.jar'
        }
    }
}

// 🔒 LOCKED COMPONENT - Client-Only JAR Configuration
// This creates a client JAR without server-side dependencies that cause module conflicts
task clientJar(type: Jar, dependsOn: 'classes') {
    archiveBaseName = 'minefest-essentials'
    archiveClassifier = 'client'
    
    manifest {
        attributes([
            "Specification-Title": "minefest",
            "Specification-Vendor": "minefestsareus", 
            "Specification-Version": "1",
            "Implementation-Title": project.name,
            "Implementation-Version": project.jar.archiveVersion,
            "Implementation-Vendor" :"minefestsareus",
            "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
        ])
    }
    
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    
    // Include only the mod classes and resources, NO jarJar dependencies
    from sourceSets.main.output
    
    // Exclude server-side components that clients don't need
    exclude '**/audio/**'  // Server-side audio streaming
    exclude '**/bungee/**' // Server-side BungeeCord integration
    
    doLast {
        println "CLIENT JAR: Created ${archiveFile.get().asFile.name} without server dependencies"
    }
}

task copyModToClientMods(type: Copy, dependsOn: 'clientJar') {
    from tasks.clientJar
    into 'c:/Users/rstic/curseforge/minecraft/Instances/Minefest (1)/mods'
    doFirst {
        // Remove old versions of our mod
        delete fileTree('c:/Users/rstic/curseforge/minecraft/Instances/Minefest (1)/mods') {
            include 'minefest-essentials-*.jar'
        }
        println "CLIENT DEPLOY: Deploying client-only JAR (no LavaPlayer conflicts)"
    }
    onlyIf {
        // Only copy if the CurseForge directory exists
        file('c:/Users/rstic/curseforge/minecraft/Instances/Minefest (1)/mods').exists()
    }
}

// 🔒 LOCKED COMPONENT - BuildAll Task
// This comprehensive build task is locked for environment synchronization stability
// 🔒 LOCKED COMPONENT - Build Directory Restoration Task
// This task ensures build directory is restored before deployment tasks run
task restoreBuildDirectory {
    description 'Restores build directory from any backup locations (fixes deployment timing issues)'
    
    doLast {
        def buildDir = file('build')
        def serverBackup = file('build-backup-temp')
        def clientBackup = file('build-backup-temp-client')
        
        // Restore from any backup location
        if (!buildDir.exists()) {
            if (serverBackup.exists()) {
                serverBackup.renameTo(buildDir)
                println "BUILDALL: Restored build directory from server backup"
            } else if (clientBackup.exists()) {
                clientBackup.renameTo(buildDir)
                println "BUILDALL: Restored build directory from client backup"
            }
        } else {
            // Clean up any leftover backups
            if (serverBackup.exists()) {
                delete serverBackup
                println "BUILDALL: Cleaned up server backup directory"
            }
            if (clientBackup.exists()) {
                delete clientBackup
                println "BUILDALL: Cleaned up client backup directory"
            }
        }
    }
}

task buildAll {
    dependsOn 'clean', 'build', 'restoreBuildDirectory', 'copyModToRunMods', 'copyModToServerMods', 'copyModToClientMods'
    group = 'minefest'
    description = 'Clean build and deploy to development (run/mods), production (server/mods), and client (CurseForge) environments'
    
    doLast {
        println "✅ Built and deployed Minefest-Core v${project.version}"
        println "📁 Development environment: run/mods/"
        println "🚀 Production environment: server/mods/"
        println "🎮 Client environment: CurseForge/Minefest (1)/mods/"
        println ""
        println "Ready to start:"
        println "  Development: ./gradlew runServer"
        println "  Production:  cd server && ./run.bat"
        println "  Client:      Launch from CurseForge app"
    }
}

// Development JAR task removed - using clean module conflict resolution instead

// 🔒 LOCKED COMPONENT - Run Task Dependencies
// These task dependencies are locked for proper build coordination
// Client dependencies moved to comprehensive task configuration below

// 🔒 LOCKED COMPONENT - Server Run Task Configuration
// This complex server run configuration is locked as it solves critical module conflicts
tasks.whenTaskAdded { task ->
    if (task.name == 'runServer') {
        task.dependsOn 'copyModToRunMods', 'copyModToServerMods'
        
        task.doFirst {
            // More aggressive build directory hiding
            def buildDir = file('build')
            def buildBackup = file('build-backup-temp')
            
            if (buildDir.exists()) {
                if (buildBackup.exists()) {
                    delete buildBackup
                }
                buildDir.renameTo(buildBackup)
                println "MINEFEST: Temporarily moved build directory to prevent module conflicts"
            }
            
            // Also try to exclude from classpath if possible  
            systemProperty 'fml.disableResourceCache', 'true'
        }
        
        task.doLast {
            // Restore build directory after server run
            def buildDir = file('build')
            def buildBackup = file('build-backup-temp')
            
            if (buildBackup.exists() && !buildDir.exists()) {
                buildBackup.renameTo(buildDir)
                println "MINEFEST: Restored build directory"
            }
        }
    }
    
    // APPLY SAME FIX TO CLIENT - Module conflict resolution
    if (task.name == 'runClient') {
        // No extra dependencies needed - use pure classpath development
        
        task.doFirst {
            // CLIENT FIX: Same approach as server - hide build directory to prevent module conflicts
            def buildDir = file('build')
            def buildBackup = file('build-backup-temp-client')
            
            if (buildDir.exists()) {
                if (buildBackup.exists()) {
                    delete buildBackup
                }
                buildDir.renameTo(buildBackup)
                println "MINEFEST CLIENT: Temporarily moved build directory to prevent module conflicts"
            }
            
            // Clear ALL mod JARs - client will use pure classpath development
            delete fileTree('run/mods') { include '*.jar' }
            
            println "Client starting with pure classpath development (no module conflicts)"
            println "Mod will be loaded from Gradle classpath instead of JARs"
        }
        
        task.doLast {
            // Restore build directory after client run
            def buildDir = file('build')
            def buildBackup = file('build-backup-temp-client')
            
            if (buildBackup.exists() && !buildDir.exists()) {
                buildBackup.renameTo(buildDir)
                println "MINEFEST CLIENT: Restored build directory"
            }
        }
    }
}

// Development JAR cleanup removed - no longer using dev JARs

// 🔒 LOCKED COMPONENT - Client Run Configuration
// This client run configuration is locked for development stability
// Client configuration moved to comprehensive task configuration above

// 🔒 LOCKED COMPONENT - Clean Server Run Task
// This custom server run task is locked for conflict resolution stability
task runServerClean(type: JavaExec, dependsOn: ['copyModToRunMods', 'copyModToServerMods']) {
    group = 'minefest'
    description = 'Run the server without build directory conflicts'
    
    workingDir project.file('run')
    
    classpath = configurations.runtimeClasspath
    mainClass = 'net.minecraftforge.userdev.LaunchTesting'
    
    args '--launchTarget', 'forge_userdev_server'
    args '--gameDir', '.'
    
    jvmArgs '--add-modules', 'ALL-SYSTEM'
    jvmArgs '--illegal-access=permit'
    jvmArgs '--add-opens=java.base/java.util.jar=ALL-UNNAMED'
    jvmArgs '--add-opens=java.base/java.lang.reflect=ALL-UNNAMED'
    jvmArgs '--add-opens=java.base/java.text=ALL-UNNAMED'
    jvmArgs '--add-opens=java.desktop/java.awt.font=ALL-UNNAMED'
    jvmArgs '--add-exports=java.base/sun.security.util=ALL-UNNAMED'
    jvmArgs '--add-exports=jdk.naming.dns/com.sun.jndi.dns=java.naming'
    
    systemProperty 'forge.logging.markers', 'REGISTRIES'
    systemProperty 'forge.logging.console.level', 'debug'
    systemProperty 'forge.enabledGameTestNamespaces', 'minefest'
    systemProperty 'fml.disableModClasspathScanning', 'true'
}

// 🔒 LOCKED COMPONENT - Version Automation System
// This comprehensive versioning system is locked for consistency and reliability
// ⚡ VERSION AUTOMATION SYSTEM
// Comprehensive versioning system that updates all project version references

/**
 * 🔒 LOCKED COMPONENT - Core Version Update Task
 * Updates all version references throughout the project from the primary source (gradle.properties)
 * 
 * Primary Version Source: gradle.properties -> mod_version
 * Target Files Updated:
 * - docs/README.md (version badges and current version references) 
 * - docs/CURRENT_DEVELOPMENT_STATUS.md (current version)
 * - docs/BUILD_WORKFLOW.md (last updated version reference)
 * - docs/CHANGELOG.md (creates new version entry if needed)
 * - docs/TROUBLESHOOTING.md (last updated version reference)
 */
task updateProjectVersions {
    description 'Updates all version references throughout the project from gradle.properties'
    group = 'minefest'
    
    doLast {
        def currentVersion = project.mod_version
        def currentDate = new Date().format('yyyy-MM-dd')
        
        println "🎯 Updating project versions to: ${currentVersion}"
        
        // Update README.md version badge and current version
        def readmeFile = file('docs/README.md')
        if (readmeFile.exists()) {
            def readmeContent = readmeFile.text
            // Update version badge (shields.io format)
            readmeContent = readmeContent.replaceAll(
                /\[!\[Version\]\(https:\/\/img\.shields\.io\/badge\/version-[^)]+-blue\.svg\)\]/,
                "[![Version](https://img.shields.io/badge/version-${currentVersion.replace('-', '--')}-blue.svg)]"
            )
            // Update "Current Features" header version
            readmeContent = readmeContent.replaceAll(
                /## ✨ Current Features \(v[^)]+\)/,
                "## ✨ Current Features (v${currentVersion})"
            )
            // Update footer current version (bold with emoji format)
            readmeContent = readmeContent.replaceAll(
                /\*\*:headphones: Current Version\*\*: `[^`]+`/,
                "**:headphones: Current Version**: `${currentVersion}`"
            )
            // Also handle backup file format
            readmeContent = readmeContent.replaceAll(
                /\*\*🎧 Current Version\*\*: `[^`]+`/,
                "**🎧 Current Version**: `${currentVersion}`"
            )
            // Update footer last updated
            readmeContent = readmeContent.replaceAll(
                /\*Last Updated: [^*]+\*/,
                "*Last Updated: ${currentDate}*"
            )
            readmeFile.text = readmeContent
            println "✅ Updated docs/README.md"
        }
        
        // Update CURRENT_DEVELOPMENT_STATUS.md
        def statusFile = file('docs/CURRENT_DEVELOPMENT_STATUS.md')
        if (statusFile.exists()) {
            def statusContent = statusFile.text
            statusContent = statusContent.replaceAll(
                /\*\*Current Version\*\*: `[^`]+`/,
                "**Current Version**: `${currentVersion}`"
            )
            statusContent = statusContent.replaceAll(
                /\*\*Last Updated\*\*: [^\n]+/,
                "**Last Updated**: ${currentDate}"
            )
            statusFile.text = statusContent
            println "✅ Updated docs/CURRENT_DEVELOPMENT_STATUS.md"
        }
        
        // Update BUILD_WORKFLOW.md version reference
        def buildWorkflowFile = file('docs/BUILD_WORKFLOW.md')
        if (buildWorkflowFile.exists()) {
            def buildContent = buildWorkflowFile.text
            buildContent = buildContent.replaceAll(
                /\*Last Updated: [^*]+\*/,
                "*Last Updated: ${currentDate}*"
            )
            buildContent = buildContent.replaceAll(
                /\*Version: [^*]+\*/,
                "*Version: ${currentVersion}*"
            )
            buildWorkflowFile.text = buildContent
            println "✅ Updated docs/BUILD_WORKFLOW.md"
        }
        
        // Update TROUBLESHOOTING.md version reference
        def troubleshootingFile = file('docs/TROUBLESHOOTING.md')
        if (troubleshootingFile.exists()) {
            def troubleshootingContent = troubleshootingFile.text
            troubleshootingContent = troubleshootingContent.replaceAll(
                /\*Last Updated: [^*]+\*/,
                "*Last Updated: ${currentDate}*"
            )
            troubleshootingContent = troubleshootingContent.replaceAll(
                /\*Version: [^*]+\*/,
                "*Version: ${currentVersion}*"
            )
            troubleshootingFile.text = troubleshootingContent
            println "✅ Updated docs/TROUBLESHOOTING.md"
        }

        // Update ARCHITECTURE.md version reference
        def architectureFile = file('docs/ARCHITECTURE.md')
        if (architectureFile.exists()) {
            def architectureContent = architectureFile.text
            architectureContent = architectureContent.replaceAll(
                /\*\*Current Version\*\*: [^*]+/,
                "**Current Version**: ${currentVersion}"
            )
            architectureFile.text = architectureContent
            println "✅ Updated docs/ARCHITECTURE.md"
        }

        // Update API.md version reference
        def apiFile = file('docs/API.md')
        if (apiFile.exists()) {
            def apiContent = apiFile.text
            apiContent = apiContent.replaceAll(
                /\*\*Current Version\*\*: [^*]+/,
                "**Current Version**: ${currentVersion}"
            )
            apiFile.text = apiContent
            println "✅ Updated docs/API.md"
        }

        // Update PERFORMANCE.md version reference
        def performanceFile = file('docs/PERFORMANCE.md')
        if (performanceFile.exists()) {
            def performanceContent = performanceFile.text
            performanceContent = performanceContent.replaceAll(
                /\*\*Current Version\*\*: [^*]+/,
                "**Current Version**: ${currentVersion}"
            )
            performanceFile.text = performanceContent
            println "✅ Updated docs/PERFORMANCE.md"
        }

        // Update MASTERKEY.md version reference
        def masterkeyFile = file('docs/MASTERKEY.md')
        if (masterkeyFile.exists()) {
            def masterkeyContent = masterkeyFile.text
            masterkeyContent = masterkeyContent.replaceAll(
                /\*\*Project Version\*\*: [^\n]+/,
                "**Project Version**: ${currentVersion}"
            )
            masterkeyFile.text = masterkeyContent
            println "✅ Updated docs/MASTERKEY.md"
        }

        // Update README_backup.md version reference
        def readmeBackupFile = file('docs/README_backup.md')
        if (readmeBackupFile.exists()) {
            def readmeBackupContent = readmeBackupFile.text
            readmeBackupContent = readmeBackupContent.replaceAll(
                /\*\*🎧 Current Version\*\*: `[^`]+`/,
                "**🎧 Current Version**: `${currentVersion}`"
            )
            readmeBackupFile.text = readmeBackupContent
            println "✅ Updated docs/README_backup.md"
        }

        // Update ROADMAP.md version references
        def roadmapFile = file('docs/ROADMAP.md')
        if (roadmapFile.exists()) {
            def roadmapContent = roadmapFile.text
            roadmapContent = roadmapContent.replaceAll(
                /v1\.20\.4-[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/,
                "v${currentVersion}"
            )
            roadmapFile.text = roadmapContent
            println "✅ Updated docs/ROADMAP.md"
        }

        // Update VERSIONING.md current version example
        def versioningFile = file('docs/VERSIONING.md')
        if (versioningFile.exists()) {
            def versioningContent = versioningFile.text
            versioningContent = versioningContent.replaceAll(
                /`1\.20\.4-[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+` \(current version\)/,
                "`${currentVersion}` (current version)"
            )
            versioningContent = versioningContent.replaceAll(
                /We are currently at version `1\.20\.4-[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+`/,
                "We are currently at version `${currentVersion}`"
            )
            // Update footer version
            versioningContent = versioningContent.replaceAll(
                /\*Versioning Guide Version: [^*]+\*/,
                "*Versioning Guide Version: ${currentVersion}*"
            )
            versioningFile.text = versioningContent
            println "✅ Updated docs/VERSIONING.md"
        }

        // Update other files with footer version patterns
        def filesToUpdateFooters = [
            'docs/CONTRIBUTING.md': /\*Contributing Guide Version: [^\n*]+/,
            'docs/DEPLOYMENT.md': /\*Version: [^\n*]+/,
            'docs/API.md': /\*API Version: [^\n*]+/,
            'docs/PERFORMANCE.md': /\*Performance Guide Version: [^\n*]+/,
            'docs/PERMISSIONS.md': /\*\*Version\*\*: [^\n*]+/,
            'docs/ROADMAP.md': /\*Roadmap Version: [^\n*]+/,
            'docs/PROJECT_STATS.md': /\*\*Version\*\*: [^\n*]+/
        ]
        
        filesToUpdateFooters.each { filePath, pattern ->
            def file = project.file(filePath)
            if (file.exists()) {
                def content = file.text
                // Determine replacement based on pattern
                def replacement
                if (filePath.contains('PERMISSIONS.md') || filePath.contains('PROJECT_STATS.md')) {
                    replacement = "**Version**: ${currentVersion}"
                } else {
                    replacement = "*${filePath.split('/')[1].replace('.md', '')} Version: ${currentVersion}*"
                    if (filePath.contains('DEPLOYMENT.md')) {
                        replacement = "*Version: ${currentVersion}*"
                    } else if (filePath.contains('API.md')) {
                        replacement = "*API Version: ${currentVersion}*"
                    } else if (filePath.contains('PERFORMANCE.md')) {
                        replacement = "*Performance Guide Version: ${currentVersion}*"
                    } else if (filePath.contains('CONTRIBUTING.md')) {
                        replacement = "*Contributing Guide Version: ${currentVersion}*"
                    } else if (filePath.contains('ROADMAP.md')) {
                        replacement = "*Roadmap Version: ${currentVersion}*"
                    }
                }
                content = content.replaceAll(pattern, replacement)
                file.text = content
                println "✅ Updated ${filePath}"
            }
        }
        
        // Check if CHANGELOG.md needs a new version entry
        def changelogFile = file('docs/CHANGELOG.md')
        if (changelogFile.exists()) {
            def changelogContent = changelogFile.text
            if (!changelogContent.contains("## [${currentVersion}]")) {
                // Add new changelog entry template
                def newEntry = """## [${currentVersion}] - ${currentDate}

### Added
- 

### Enhanced
- 

### Fixed
- 

### Documentation
- Version update to ${currentVersion}

---

"""
                changelogContent = changelogContent.replace(
                    '# Minefest-Core Changelog\n\n',
                    "# Minefest-Core Changelog\n\n${newEntry}"
                )
                changelogFile.text = changelogContent
                println "✅ Created new CHANGELOG.md entry for ${currentVersion}"
            } else {
                println "ℹ️  CHANGELOG.md already has entry for ${currentVersion}"
            }
        }
        
        println "🎉 Version update complete! All files updated to ${currentVersion}"
        println ""
        println "📝 Next steps:"
        println "   1. Review and edit the new CHANGELOG.md entry"
        println "   2. Update any stage completion status in CURRENT_DEVELOPMENT_STATUS.md"
        println "   3. Commit version changes: git add -A && git commit -m \"Version ${currentVersion}\""
    }
}

/**
 * 🔒 LOCKED COMPONENT - Automated Version Increment Utilities
 * These tasks increment version numbers automatically and update all references
 * Lock Reason: Stable task dependencies and proper version number logic
 */

task incrementPatch {
    description 'Increments patch version (X.X.X.Y -> X.X.X.Y+1) and updates all references'
    group = 'minefest'
    finalizedBy updateProjectVersions
    // 🔒 LOCKED: Task dependencies and version logic are stable
    
    doLast {
        def currentVersion = project.mod_version
        def versionParts = currentVersion.split('-')
        def mcVersion = versionParts[0] // e.g., "1.20.4"
        def modVersionParts = versionParts[1].split('\\.')
        
        def major = modVersionParts[0]
        def minor = modVersionParts[1] 
        def patch = modVersionParts[2]
        def build = modVersionParts.length > 3 ? (modVersionParts[3] as Integer) + 1 : 1
        
        def newVersion = "${mcVersion}-${major}.${minor}.${patch}.${build}"
        
        // Update gradle.properties
        def gradlePropsFile = file('gradle.properties')
        def gradlePropsContent = gradlePropsFile.text
        gradlePropsContent = gradlePropsContent.replaceAll(
            /mod_version=[^\n]+/,
            "mod_version=${newVersion}"
        )
        gradlePropsFile.text = gradlePropsContent
        
        println "🔢 Incremented patch version: ${currentVersion} -> ${newVersion}"
        println "📄 Updated gradle.properties"
    }
}

task incrementMinor {
    description 'Increments minor version (X.X.Y.Z -> X.X.Y+1.0) and updates all references'
    group = 'minefest'
    finalizedBy updateProjectVersions
    // 🔒 LOCKED: Task dependencies and version logic are stable
    
    doLast {
        def currentVersion = project.mod_version
        def versionParts = currentVersion.split('-')
        def mcVersion = versionParts[0] // e.g., "1.20.4"
        def modVersionParts = versionParts[1].split('\\.')
        
        def major = modVersionParts[0]
        def minor = (modVersionParts[1] as Integer) + 1
        def patch = modVersionParts[2]
        def build = 0
        
        def newVersion = "${mcVersion}-${major}.${minor}.${patch}.${build}"
        
        // Update gradle.properties
        def gradlePropsFile = file('gradle.properties')
        def gradlePropsContent = gradlePropsFile.text
        gradlePropsContent = gradlePropsContent.replaceAll(
            /mod_version=[^\n]+/,
            "mod_version=${newVersion}"
        )
        gradlePropsFile.text = gradlePropsContent
        
        println "🔢 Incremented minor version: ${currentVersion} -> ${newVersion}"
        println "📄 Updated gradle.properties"
    }
}

task incrementMajor {
    description 'Increments major version (X.Y.Z.W -> X.Y+1.0.0) and updates all references'
    group = 'minefest'
    finalizedBy updateProjectVersions
    // 🔒 LOCKED: Task dependencies and version logic are stable
    
    doLast {
        def currentVersion = project.mod_version
        def versionParts = currentVersion.split('-')
        def mcVersion = versionParts[0] // e.g., "1.20.4"
        def modVersionParts = versionParts[1].split('\\.')
        
        def major = (modVersionParts[0] as Integer) + 1
        def minor = 0
        def patch = modVersionParts[2]
        def build = 0
        
        def newVersion = "${mcVersion}-${major}.${minor}.${patch}.${build}"
        
        // Update gradle.properties
        def gradlePropsFile = file('gradle.properties')
        def gradlePropsContent = gradlePropsFile.text
        gradlePropsContent = gradlePropsContent.replaceAll(
            /mod_version=[^\n]+/,
            "mod_version=${newVersion}"
        )
        gradlePropsFile.text = gradlePropsContent
        
        println "🔢 Incremented major version: ${currentVersion} -> ${newVersion}"
        println "📄 Updated gradle.properties"
    }
}

// 🔒 LOCKED COMPONENT - Build Integration
// Automatically run version updates after buildAll - this integration is locked for workflow stability
buildAll.finalizedBy updateProjectVersions

// 🔒 LOCKED COMPONENT - Lock Protocol Validation Task
// This validation task is locked for code protection stability
task validateLocks {
    description 'Validates that locked components have not been modified without approval'
    group = 'verification'
    
    doLast {
        def lockedFiles = [
            'src/main/java/com/minefest/essentials/config/MinefestConfig.java',
            'src/main/java/com/minefest/essentials/MinefestCore.java'
        ]
        
        def violations = []
        
        lockedFiles.each { filePath ->
            def file = project.file(filePath)
            if (file.exists()) {
                def content = file.text
                if (!content.contains('🔒 LOCKED COMPONENT')) {
                    violations.add("${filePath} is marked as locked but missing lock comment")
                }
            }
        }
        
        if (!violations.isEmpty()) {
            println "⚠️  LOCK PROTOCOL VIOLATIONS DETECTED:"
            violations.each { println "   - ${it}" }
            println "\n📖 Review docs/CODE_LOCKING_PROTOCOL.md for procedures"
            println "🔒 Locked files require user approval before modification"
        } else {
            println "✅ Lock protocol compliance verified"
        }
    }
}

// Run lock validation before build
build.dependsOn validateLocks

// ================================================================================
// COMPONENT SIGNPOST [Index: BUILD-02]
// Purpose: Git automation system for version management
// Architecture: Conservative git operations with safety checks
// Side: BUILD/GIT - affects version control and documentation
// Dependencies: Git CLI, version automation tasks
// 
// KEY FEATURES:
// - Safe version file staging (explicit file list, no wildcards)
// - Standardized commit messages for version tracking
// - NO automatic push (manual control for stability)
// - Error handling with graceful fallback
// - Integration with version increment tasks
// 
// SAFETY FEATURES:
// - Explicit file list (no wildcards)
// - Git status checking before operations
// - Clear success/failure feedback
// - Manual push instructions provided
//
// ================================================================================

// ==========================================
// GIT AUTOMATION SYSTEM - COMMIT ONLY
// Conservative git automation for version management  
// Added 2025-05-23 for automated version file management
// ==========================================

/**
 * Conservative Git Automation for Version Management
 * 
 * Features:
 * - Stages ONLY version-related files (safe file selection)
 * - Standardized commit messages for version tracking
 * - NO automatic push (manual control for stability)
 * - Error handling with graceful fallback
 * - Integration with existing version increment tasks
 * - Automatic project-wide version updates before every commit
 * 
 * Safety Features:
 * - Explicit file list (no wildcards)
 * - Git status checking before operations
 * - Clear success/failure feedback
 * - Manual push instructions provided
 * 
 * Usage:
 * - ./gradlew gitCommitVersion              (commit current version changes)
 * - ./gradlew incrementPatchAndCommit       (increment + commit)
 * - ./gradlew incrementMinorAndCommit       (increment + commit) 
 * - ./gradlew incrementMajorAndCommit       (increment + commit)
 * 
 * After any commit, manually push when ready:
 * - git push origin main
 */

task gitCommitVersion {
    description 'Commits version-related file changes with standardized message (NO push)'
    group = 'minefest'
    dependsOn updateProjectVersions
    
    doLast {
        def currentVersion = project.mod_version
        def currentDate = new Date().format('yyyy-MM-dd')
        
        println "Starting git commit for version ${currentVersion}..."
        
        // Define ONLY the version-related files we want to commit
        def versionFiles = [
            'gradle.properties',
            'docs/README.md', 
            'docs/CURRENT_DEVELOPMENT_STATUS.md',
            'docs/BUILD_WORKFLOW.md',
            'docs/CHANGELOG.md',
            'docs/TROUBLESHOOTING.md'
        ]
        
        // Stage only the version files that exist
        def stagedFiles = []
        versionFiles.each { filePath ->
            def file = project.file(filePath)
            if (file.exists()) {
                try {
                    exec {
                        commandLine 'git', 'add', filePath
                        ignoreExitValue false
                    }
                    stagedFiles.add(filePath)
                    println "Staged: ${filePath}"
                } catch (Exception e) {
                    println "Could not stage ${filePath}: ${e.message}"
                }
            } else {
                println "Skipped (not found): ${filePath}"
            }
        }
        
        if (stagedFiles.isEmpty()) {
            println "No version files to commit"
            return
        }
        
        // Create standardized commit message
        def commitMessage = "v${currentVersion}: Version Update - ${currentDate}"
        
        // Attempt to commit
        try {
            exec {
                commandLine 'git', 'commit', '-m', commitMessage
                ignoreExitValue false
            }
            println "Git commit successful!"
            println "Commit message: ${commitMessage}"
            println "Files committed: ${stagedFiles.join(', ')}"
            println ""
            println "Next step: Push when ready with:"
            println "   git push origin main"
            
        } catch (Exception e) {
            println "Git commit info: ${e.message}"
            println "This might mean no changes to commit, which is normal"
            println "Check status with: git status"
        }
    }
}

task gitStatusCheck {
    description 'Checks git status and provides helpful information'
    group = 'minefest'
    
    doLast {
        try {
            def gitStatus = new ByteArrayOutputStream()
            exec {
                commandLine 'git', 'status', '--porcelain'
                standardOutput = gitStatus
            }
            
            def statusText = gitStatus.toString().trim()
            
            if (statusText.isEmpty()) {
                println "Git working directory is clean"
                println "Ready for version operations"
            } else {
                println "Git status summary:"
                statusText.split('\n').each { line ->
                    if (line.trim()) {
                        def status = line.substring(0, 2)
                        def file = line.substring(3)
                        def statusDesc = ""
                        
                        switch(status.trim()) {
                            case 'M': statusDesc = "Modified"; break
                            case 'A': statusDesc = "Added"; break
                            case 'D': statusDesc = "Deleted"; break
                            case '??': statusDesc = "Untracked"; break
                            default: statusDesc = "Changed"
                        }
                        
                        println "   ${statusDesc}: ${file}"
                    }
                }
                println ""
                println "Version automation will only commit version-related files"
            }
            
        } catch (Exception e) {
            println "Could not check git status: ${e.message}"
        }
    }
}

// Enhanced version increment tasks with git commit automation
task incrementPatchAndCommit {
    description 'Increments patch version and commits to git (NO push)'
    group = 'minefest'
    dependsOn incrementPatch
    finalizedBy gitCommitVersion
    
    doLast {
        def currentVersion = project.mod_version
        println "Patch version increment and commit workflow complete!"
        println "New version: ${currentVersion}"
        println "Files updated and committed automatically"
        println "Push when ready: git push origin main"
    }
}

task incrementMinorAndCommit {
    description 'Increments minor version and commits to git (NO push)'  
    group = 'minefest'
    dependsOn incrementMinor
    finalizedBy gitCommitVersion
    
    doLast {
        def currentVersion = project.mod_version
        println "Minor version increment and commit workflow complete!"
        println "New version: ${currentVersion} (typically for stage completions)"
        println "Files updated and committed automatically"
        println "Push when ready: git push origin main"
    }
}

task incrementMajorAndCommit {
    description 'Increments major version and commits to git (NO push)'
    group = 'minefest'
    dependsOn incrementMajor
    finalizedBy gitCommitVersion
    
    doLast {
        def currentVersion = project.mod_version
        println "Major version increment and commit workflow complete!"
        println "New version: ${currentVersion} (major milestone!)"
        println "Files updated and committed automatically"
        println "Push when ready: git push origin main"
    }
}

// Update the existing updateProjectVersions task to provide git guidance
updateProjectVersions.doLast {
    println ""
    println "Git Automation Available:"
    println "   ./gradlew gitCommitVersion        (commit current changes)"
    println "   ./gradlew gitStatusCheck          (check what's changed)"
    println "   ./gradlew incrementPatchAndCommit (version bump + commit)"
}

// ==========================================
// GIT ROLLBACK & HISTORY AUTOMATION SYSTEM
// Advanced version history management and rollback capabilities
// ==========================================

task gitVersionHistory {
    description 'Shows clean version history with rollback information'
    group = 'minefest'
    
    doLast {
        def currentVersion = project.mod_version
        
        println "🕒 Version History for Minefest-Core:"
        println "📍 Current Version: ${currentVersion}"
        println ""
        
        try {
            def gitLog = new ByteArrayOutputStream()
            exec {
                commandLine 'git', 'log', '--oneline', '--grep=Version Update', '-10'
                standardOutput = gitLog
            }
            
            def logLines = gitLog.toString().trim().split('\n')
            
            if (logLines.size() > 0 && !logLines[0].trim().isEmpty()) {
                println "📋 Recent Version Commits (rollback targets):"
                logLines.eachWithIndex { line, index ->
                    if (line.trim()) {
                        def parts = line.split(' ', 2)
                        def commitHash = parts[0]
                        def message = parts.length > 1 ? parts[1] : ""
                        
                        // Extract version from commit message
                        def versionMatch = message =~ /v([^:]+):/
                        def version = versionMatch ? versionMatch[0][1] : "unknown"
                        
                        def indicator = index == 0 ? "👉" : "  "
                        println "${indicator} ${commitHash} - v${version}"
                        
                        if (index == 0) {
                            println "     Current version (HEAD)"
                        } else {
                            println "     Rollback: ./gradlew gitRollbackToVersion -Pversion=${version}"
                        }
                    }
                }
                
                println ""
                println "🔄 Rollback Options:"
                println "   ./gradlew gitVersionHistory           (show this history)"
                println "   ./gradlew gitRollbackToVersion -Pversion=X.X.X.X (rollback to version)"
                println "   ./gradlew gitCreateVersionTag         (tag current version)"
                println ""
                println "⚠️  Rollbacks modify git history - ensure you understand the impact!"
                
            } else {
                println "ℹ️  No version update commits found in recent history"
            }
            
        } catch (Exception e) {
            println "⚠️  Could not retrieve git history: ${e.message}"
        }
    }
}

task gitRollbackToVersion {
    description 'Rollback to a specific version (DANGEROUS - modifies git history)'
    group = 'minefest'
    
    doLast {
        def targetVersion = project.findProperty('version')
        
        if (!targetVersion) {
            println "❌ Error: Version not specified"
            println "Usage: ./gradlew gitRollbackToVersion -Pversion=1.20.4-0.2.3.1"
            println ""
            println "📋 Available versions:"
            exec {
                commandLine 'git', 'log', '--oneline', '--grep=Version Update', '-5'
            }
            return
        }
        
        def currentVersion = project.mod_version
        
        if (targetVersion == currentVersion) {
            println "ℹ️  Already at version ${targetVersion}"
            return
        }
        
        println "⚠️  ROLLBACK OPERATION"
        println "📍 Current Version: ${currentVersion}"
        println "🎯 Target Version: ${targetVersion}"
        println ""
        
        try {
            // Find the commit hash for the target version
            def gitLog = new ByteArrayOutputStream()
            exec {
                commandLine 'git', 'log', '--oneline', '--grep=Version Update', '-20'
                standardOutput = gitLog
            }
            
            def targetCommit = null
            gitLog.toString().split('\n').each { line ->
                if (line.contains("v${targetVersion}:")) {
                    targetCommit = line.split(' ')[0]
                }
            }
            
            if (!targetCommit) {
                println "❌ Error: Version ${targetVersion} not found in git history"
                println "Use ./gradlew gitVersionHistory to see available versions"
                return
            }
            
            println "🔍 Found target commit: ${targetCommit}"
            println ""
            println "This will:"
            println "  1. Reset to commit ${targetCommit}"
            println "  2. Update gradle.properties to version ${targetVersion}"
            println "  3. Run updateProjectVersions to sync all documentation"
            println "  4. Create a new commit with the rollback"
            println ""
            println "⚠️  DANGER: This modifies git history!"
            println "⚠️  Make sure you have pushed recent changes before proceeding"
            println ""
            println "❌ SAFETY STOP: Automated rollback disabled for safety"
            println "🔧 Manual rollback instructions:"
            println "   git reset --hard ${targetCommit}"
            println "   ./gradlew updateProjectVersions"
            println "   git add -A"
            println "   git commit -m \"Rollback to v${targetVersion}\""
            
        } catch (Exception e) {
            println "❌ Error during rollback preparation: ${e.message}"
        }
    }
}

task gitCreateVersionTag {
    description 'Create a git tag for the current version'
    group = 'minefest'
    
    doLast {
        def currentVersion = project.mod_version
        def currentDate = new Date().format('yyyy-MM-dd')
        
        println "🏷️  Creating version tag for v${currentVersion}..."
        
        try {
            // Check if tag already exists
            def checkTag = new ByteArrayOutputStream()
            def checkResult = exec {
                commandLine 'git', 'tag', '-l', "v${currentVersion}"
                standardOutput = checkTag
                ignoreExitValue true
            }
            
            if (checkTag.toString().trim()) {
                println "ℹ️  Tag v${currentVersion} already exists"
                return
            }
            
            // Create annotated tag
            def tagMessage = "Release v${currentVersion} - ${currentDate}"
            exec {
                commandLine 'git', 'tag', '-a', "v${currentVersion}", '-m', tagMessage
                ignoreExitValue false
            }
            
            println "✅ Created tag: v${currentVersion}"
            println "📝 Tag message: ${tagMessage}"
            println ""
            println "🚀 To push tag to remote:"
            println "   git push origin v${currentVersion}"
            println "   git push --tags  (push all tags)"
            
        } catch (Exception e) {
            println "❌ Error creating tag: ${e.message}"
        }
    }
}

// CREATIVE_MODE_TAB Fix: Properly configure reobf extension to disable obfuscation
// This prevents NoSuchFieldError in CurseForge client for registry fields like CREATIVE_MODE_TAB
reobf {
    // Disable obfuscation to fix client-side field reference errors
    jar {
        enabled = false
    }
}